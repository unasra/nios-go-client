/*
IbClient

OpenAPI 3.x.x specification for the IbClient API

API version: 3.0.0
Contact: jkhatri@infoblox.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dns

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/unasra/nios-go-client/internal"
)

type RecordaAPI interface {
	/*
		Get Method for Get

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return RecordaAPIGetRequest
	*/
	Get(ctx context.Context) RecordaAPIGetRequest

	// GetExecute executes the request
	//  @return []RecordA
	GetExecute(r RecordaAPIGetRequest) ([]RecordA, *http.Response, error)
	/*
		Post Method for Post

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return RecordaAPIPostRequest
	*/
	Post(ctx context.Context) RecordaAPIPostRequest

	// PostExecute executes the request
	//  @return string
	PostExecute(r RecordaAPIPostRequest) (string, *http.Response, error)
	/*
		RecordaReferenceDelete Method for RecordaReferenceDelete

		Delete the record:a resource

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param recordaReference Enter the reference for record:a
		@return RecordaAPIRecordaReferenceDeleteRequest
	*/
	RecordaReferenceDelete(ctx context.Context, recordaReference string) RecordaAPIRecordaReferenceDeleteRequest

	// RecordaReferenceDeleteExecute executes the request
	//  @return string
	RecordaReferenceDeleteExecute(r RecordaAPIRecordaReferenceDeleteRequest) (string, *http.Response, error)
	/*
		RecordaReferenceGet Method for RecordaReferenceGet

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param recordaReference Enter the reference for record:a
		@return RecordaAPIRecordaReferenceGetRequest
	*/
	RecordaReferenceGet(ctx context.Context, recordaReference string) RecordaAPIRecordaReferenceGetRequest

	// RecordaReferenceGetExecute executes the request
	//  @return RecordA
	RecordaReferenceGetExecute(r RecordaAPIRecordaReferenceGetRequest) (*RecordA, *http.Response, error)
	/*
		RecordaReferencePut Method for RecordaReferencePut

		Update the record:a resource

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param recordaReference Enter the reference for record:a
		@return RecordaAPIRecordaReferencePutRequest
	*/
	RecordaReferencePut(ctx context.Context, recordaReference string) RecordaAPIRecordaReferencePutRequest

	// RecordaReferencePutExecute executes the request
	//  @return string
	RecordaReferencePutExecute(r RecordaAPIRecordaReferencePutRequest) (string, *http.Response, error)
}

// RecordaAPIService RecordaAPI service
type RecordaAPIService internal.Service

type RecordaAPIGetRequest struct {
	ctx              context.Context
	ApiService       RecordaAPI
	returnFields     *string
	returnFields2    *string
	maxResults       *int32
	returnAsObject   *int32
	paging           *int32
	pageId           *string
	proxySearch      *string
	schema           *string
	schemaVersion    *int32
	getDoc           *int32
	schemaSearchable *int32
	inheritance      *bool
	comment          *string
	creator          *string
	ddnsPrincipal    *string
	ipv4addr         *string
	name             *string
	reclaimable      *string
	view             *string
	zone             *string
}

// Enter the field names followed by comma
func (r RecordaAPIGetRequest) ReturnFields(returnFields string) RecordaAPIGetRequest {
	r.returnFields = &returnFields
	return r
}

// Enter the field names followed by comma, this returns the required fields along with the default fields
func (r RecordaAPIGetRequest) ReturnFields2(returnFields2 string) RecordaAPIGetRequest {
	r.returnFields2 = &returnFields2
	return r
}

// Enter the number of results to be fetched
func (r RecordaAPIGetRequest) MaxResults(maxResults int32) RecordaAPIGetRequest {
	r.maxResults = &maxResults
	return r
}

// Select 1 if result is required as an object
func (r RecordaAPIGetRequest) ReturnAsObject(returnAsObject int32) RecordaAPIGetRequest {
	r.returnAsObject = &returnAsObject
	return r
}

// Select 1 if paging is required. If SET, _max_results and _return_as_object must be entered.
func (r RecordaAPIGetRequest) Paging(paging int32) RecordaAPIGetRequest {
	r.paging = &paging
	return r
}

// Enter the page ID for fetching the next page
func (r RecordaAPIGetRequest) PageId(pageId string) RecordaAPIGetRequest {
	r.pageId = &pageId
	return r
}

// If set to GM, the request is redirected to Grid master for processing. If set to LOCAL, the request is processed locally. This option is applicable only on vConnector grid members. The default is LOCAL.
func (r RecordaAPIGetRequest) ProxySearch(proxySearch string) RecordaAPIGetRequest {
	r.proxySearch = &proxySearch
	return r
}

// If this option is specified, a WAPI schema will be returned
func (r RecordaAPIGetRequest) Schema(schema string) RecordaAPIGetRequest {
	r.schema = &schema
	return r
}

// If this option is specified, a WAPI schema of particular version will be returned. If options is omitted, schema version is assumed to be 1
func (r RecordaAPIGetRequest) SchemaVersion(schemaVersion int32) RecordaAPIGetRequest {
	r.schemaVersion = &schemaVersion
	return r
}

// When set to 1, it returns the documentation of the object.Applicable only when _schema_version is 2
func (r RecordaAPIGetRequest) GetDoc(getDoc int32) RecordaAPIGetRequest {
	r.getDoc = &getDoc
	return r
}

// If this option is specified, search only fields will also be returned. Applicable only when _schema_version is 2
func (r RecordaAPIGetRequest) SchemaSearchable(schemaSearchable int32) RecordaAPIGetRequest {
	r.schemaSearchable = &schemaSearchable
	return r
}

// If this option is set to True, fields which support inheritance, will display data properly.
func (r RecordaAPIGetRequest) Inheritance(inheritance bool) RecordaAPIGetRequest {
	r.inheritance = &inheritance
	return r
}

// Enter the value of the field
func (r RecordaAPIGetRequest) Comment(comment string) RecordaAPIGetRequest {
	r.comment = &comment
	return r
}

// Enter the value of the field
func (r RecordaAPIGetRequest) Creator(creator string) RecordaAPIGetRequest {
	r.creator = &creator
	return r
}

// Enter the value of the field
func (r RecordaAPIGetRequest) DdnsPrincipal(ddnsPrincipal string) RecordaAPIGetRequest {
	r.ddnsPrincipal = &ddnsPrincipal
	return r
}

// Enter the value of the field
func (r RecordaAPIGetRequest) Ipv4addr(ipv4addr string) RecordaAPIGetRequest {
	r.ipv4addr = &ipv4addr
	return r
}

// Enter the value of the field
func (r RecordaAPIGetRequest) Name(name string) RecordaAPIGetRequest {
	r.name = &name
	return r
}

// Enter the value of the field
func (r RecordaAPIGetRequest) Reclaimable(reclaimable string) RecordaAPIGetRequest {
	r.reclaimable = &reclaimable
	return r
}

// Enter the value of the field
func (r RecordaAPIGetRequest) View(view string) RecordaAPIGetRequest {
	r.view = &view
	return r
}

// Enter the value of the field
func (r RecordaAPIGetRequest) Zone(zone string) RecordaAPIGetRequest {
	r.zone = &zone
	return r
}

func (r RecordaAPIGetRequest) Execute() ([]RecordA, *http.Response, error) {
	return r.ApiService.GetExecute(r)
}

/*
Get Method for Get

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return RecordaAPIGetRequest
*/
func (a *RecordaAPIService) Get(ctx context.Context) RecordaAPIGetRequest {
	return RecordaAPIGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []RecordA
func (a *RecordaAPIService) GetExecute(r RecordaAPIGetRequest) ([]RecordA, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue []RecordA
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "RecordaAPIService.Get")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/record:a"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnFields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields", r.returnFields, "")
	}
	if r.returnFields2 != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields+", r.returnFields2, "")
	}
	if r.maxResults != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_max_results", r.maxResults, "")
	}
	if r.returnAsObject != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_as_object", r.returnAsObject, "")
	} else {
		var defaultValue int32 = 0
		r.returnAsObject = &defaultValue
	}
	if r.paging != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_paging", r.paging, "")
	} else {
		var defaultValue int32 = 0
		r.paging = &defaultValue
	}
	if r.pageId != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_page_id", r.pageId, "")
	}
	if r.proxySearch != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_proxy_search", r.proxySearch, "")
	}
	if r.schema != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_schema", r.schema, "")
	}
	if r.schemaVersion != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_schema_version", r.schemaVersion, "")
	}
	if r.getDoc != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_get_doc", r.getDoc, "")
	}
	if r.schemaSearchable != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_schema_searchable", r.schemaSearchable, "")
	}
	if r.inheritance != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_inheritance", r.inheritance, "")
	}
	if r.comment != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "comment", r.comment, "")
	}
	if r.creator != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "creator", r.creator, "")
	}
	if r.ddnsPrincipal != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "ddns_principal", r.ddnsPrincipal, "")
	}
	if r.ipv4addr != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "ipv4addr", r.ipv4addr, "")
	}
	if r.name != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.reclaimable != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "reclaimable", r.reclaimable, "")
	}
	if r.view != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "")
	}
	if r.zone != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "zone", r.zone, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordaAPIPostRequest struct {
	ctx            context.Context
	ApiService     RecordaAPI
	recordARequest *RecordARequest
	returnFields   *string
}

// Enter the request body here
func (r RecordaAPIPostRequest) RecordARequest(recordARequest RecordARequest) RecordaAPIPostRequest {
	r.recordARequest = &recordARequest
	return r
}

// Enter the field names followed by comma
func (r RecordaAPIPostRequest) ReturnFields(returnFields string) RecordaAPIPostRequest {
	r.returnFields = &returnFields
	return r
}

func (r RecordaAPIPostRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.PostExecute(r)
}

/*
Post Method for Post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return RecordaAPIPostRequest
*/
func (a *RecordaAPIService) Post(ctx context.Context) RecordaAPIPostRequest {
	return RecordaAPIPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return string
func (a *RecordaAPIService) PostExecute(r RecordaAPIPostRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue string
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "RecordaAPIService.Post")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/record:a"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.recordARequest == nil {
		return localVarReturnValue, nil, internal.ReportError("recordARequest is required and must be specified")
	}

	if r.returnFields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields", r.returnFields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.recordARequest
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordaAPIRecordaReferenceDeleteRequest struct {
	ctx              context.Context
	ApiService       RecordaAPI
	recordaReference string
}

func (r RecordaAPIRecordaReferenceDeleteRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.RecordaReferenceDeleteExecute(r)
}

/*
RecordaReferenceDelete Method for RecordaReferenceDelete

Delete the record:a resource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param recordaReference Enter the reference for record:a
	@return RecordaAPIRecordaReferenceDeleteRequest
*/
func (a *RecordaAPIService) RecordaReferenceDelete(ctx context.Context, recordaReference string) RecordaAPIRecordaReferenceDeleteRequest {
	return RecordaAPIRecordaReferenceDeleteRequest{
		ApiService:       a,
		ctx:              ctx,
		recordaReference: recordaReference,
	}
}

// Execute executes the request
//
//	@return string
func (a *RecordaAPIService) RecordaReferenceDeleteExecute(r RecordaAPIRecordaReferenceDeleteRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue string
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "RecordaAPIService.RecordaReferenceDelete")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/record:a/{record:a_reference}"
	localVarPath = strings.Replace(localVarPath, "{"+"record:a_reference"+"}", url.PathEscape(internal.ParameterValueToString(r.recordaReference, "recordaReference")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordaAPIRecordaReferenceGetRequest struct {
	ctx              context.Context
	ApiService       RecordaAPI
	recordaReference string
	returnFields     *string
	returnFields2    *string
	returnAsObject   *int32
}

// Enter the field names followed by comma
func (r RecordaAPIRecordaReferenceGetRequest) ReturnFields(returnFields string) RecordaAPIRecordaReferenceGetRequest {
	r.returnFields = &returnFields
	return r
}

// Enter the field names followed by comma, this returns the required fields along with the default fields
func (r RecordaAPIRecordaReferenceGetRequest) ReturnFields2(returnFields2 string) RecordaAPIRecordaReferenceGetRequest {
	r.returnFields2 = &returnFields2
	return r
}

// Select 1 if result is required as an object
func (r RecordaAPIRecordaReferenceGetRequest) ReturnAsObject(returnAsObject int32) RecordaAPIRecordaReferenceGetRequest {
	r.returnAsObject = &returnAsObject
	return r
}

func (r RecordaAPIRecordaReferenceGetRequest) Execute() (*RecordA, *http.Response, error) {
	return r.ApiService.RecordaReferenceGetExecute(r)
}

/*
RecordaReferenceGet Method for RecordaReferenceGet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param recordaReference Enter the reference for record:a
	@return RecordaAPIRecordaReferenceGetRequest
*/
func (a *RecordaAPIService) RecordaReferenceGet(ctx context.Context, recordaReference string) RecordaAPIRecordaReferenceGetRequest {
	return RecordaAPIRecordaReferenceGetRequest{
		ApiService:       a,
		ctx:              ctx,
		recordaReference: recordaReference,
	}
}

// Execute executes the request
//
//	@return RecordA
func (a *RecordaAPIService) RecordaReferenceGetExecute(r RecordaAPIRecordaReferenceGetRequest) (*RecordA, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue *RecordA
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "RecordaAPIService.RecordaReferenceGet")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/record:a/{record:a_reference}"
	localVarPath = strings.Replace(localVarPath, "{"+"record:a_reference"+"}", url.PathEscape(internal.ParameterValueToString(r.recordaReference, "recordaReference")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.returnFields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields", r.returnFields, "")
	}
	if r.returnFields2 != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields+", r.returnFields2, "")
	}
	if r.returnAsObject != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_as_object", r.returnAsObject, "")
	} else {
		var defaultValue int32 = 0
		r.returnAsObject = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}

type RecordaAPIRecordaReferencePutRequest struct {
	ctx              context.Context
	ApiService       RecordaAPI
	recordaReference string
	recordARequest   *RecordARequest
	returnFields     *string
}

// Enter the request body here
func (r RecordaAPIRecordaReferencePutRequest) RecordARequest(recordARequest RecordARequest) RecordaAPIRecordaReferencePutRequest {
	r.recordARequest = &recordARequest
	return r
}

// Enter the field names followed by comma
func (r RecordaAPIRecordaReferencePutRequest) ReturnFields(returnFields string) RecordaAPIRecordaReferencePutRequest {
	r.returnFields = &returnFields
	return r
}

func (r RecordaAPIRecordaReferencePutRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.RecordaReferencePutExecute(r)
}

/*
RecordaReferencePut Method for RecordaReferencePut

Update the record:a resource

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param recordaReference Enter the reference for record:a
	@return RecordaAPIRecordaReferencePutRequest
*/
func (a *RecordaAPIService) RecordaReferencePut(ctx context.Context, recordaReference string) RecordaAPIRecordaReferencePutRequest {
	return RecordaAPIRecordaReferencePutRequest{
		ApiService:       a,
		ctx:              ctx,
		recordaReference: recordaReference,
	}
}

// Execute executes the request
//
//	@return string
func (a *RecordaAPIService) RecordaReferencePutExecute(r RecordaAPIRecordaReferencePutRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []internal.FormFile
		localVarReturnValue string
	)

	localBasePath, err := a.Client.Cfg.ServerURLWithContext(r.ctx, "RecordaAPIService.RecordaReferencePut")
	if err != nil {
		return localVarReturnValue, nil, internal.NewGenericOpenAPIError(err.Error())
	}

	localVarPath := localBasePath + "/record:a/{record:a_reference}"
	localVarPath = strings.Replace(localVarPath, "{"+"record:a_reference"+"}", url.PathEscape(internal.ParameterValueToString(r.recordaReference, "recordaReference")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.recordARequest == nil {
		return localVarReturnValue, nil, internal.ReportError("recordARequest is required and must be specified")
	}

	if r.returnFields != nil {
		internal.ParameterAddToHeaderOrQuery(localVarQueryParams, "_return_fields", r.returnFields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := internal.SelectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := internal.SelectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.recordARequest
	req, err := a.Client.PrepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.Client.CallAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := internal.NewGenericOpenAPIErrorWithBody(localVarHTTPResponse.Status, localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.Client.Decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := internal.NewGenericOpenAPIErrorWithBody(err.Error(), localVarBody)
		return localVarReturnValue, localVarHTTPResponse, newErr
	}
	return localVarReturnValue, localVarHTTPResponse, nil
}
